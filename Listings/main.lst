C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: F:\software\keil5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /********************************** (C) COPYRIGHT *******************************
   2           * File Name          : main.c
   3           * Author             : 0x9e733e9
   4           * Version            : V0.0.1
   5           * Date               : 2023/11/29
   6           * Description        : Main program body.
   7           * Open Source License: GPL3.0
   8           * E-mail             : bsk166147049@163.com
   9           *******************************************************************************/
  10          #include <STC89C5xRC.H>
  11          #include "intrins.h"
  12          
  13          #define scale   100   //pwm的周期
  14          #define SMG_A_DP_PORT   P0  //数码管段选引脚
  15          #define EEPROM_ADDRESS  0x00    //定义数据存入EEPROM的起始地址
  16          
  17          typedef unsigned int u16;       //对系统默认数据类型进行重定义
  18          typedef unsigned char u8;       //对系统默认数据类型进行重定义
  19          
  20          //管脚定义
  21          sbit DC_Motor=P1^0;//定义直流电机控制管脚
  22          sbit KEY1=P3^1;
  23          sbit KEY2=P3^0;
  24          //sbit KEY3=P3^2;   //被红外占用P32io口
  25          sbit KEY4=P3^3;
  26          sbit LED1=P2^5;
  27          sbit LED2=P2^6;
  28          sbit LED3=P2^7;
  29          sbit LSA=P2^2;  //数码管位选引脚定义
  30          sbit LSB=P2^3;  //数码管位选引脚定义
  31          sbit LSC=P2^4;  //数码管位选引脚定义
  32          sbit IRED=P3^2; //红外引脚定义
  33          sbit DS18B20_PORT=P3^7;         //DS18B20数据口定义
  34          //定义EEPROM控制脚
  35          sbit IIC_SCL=P2^1;//SCL时钟线
  36          sbit IIC_SDA=P2^0;//SDA数据线
  37          sbit DOUT = P3^7;         //输出
  38          sbit CLK  = P3^6;         //时钟
  39          sbit DIN  = P3^4;         //输入
  40          sbit CS   = P3^5;         //片选
  41          //字库
  42          u8 gsmg_code[30]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71, 
  43                            0xbf,0x86,0xdb,0xcf,0xe6,0xed,0xfd,0x87,0xff,0xef,
  44                                                  0X76,0x73,0x00,0x40}; //H,P,buxianshi,- 
  45          //变量
  46          unsigned long int sys=0;  //定时器1系统时间
  47          //unsigned int system=0;    
  48          seg[8]={28,28,28,28,28,28,28,28}; //数码管外设数组
  49          unsigned char key;       //按键变量
  50          unsigned char key_sanf_delay,key_old;  //按键变量
  51          unsigned char key_val,key_down,key_up;  //按键变量
  52          unsigned long int seg_tag=0;     //数码管刷新依赖
  53          //u8 dir=0;     
  54          u16 duty=100;  //占空比，上电风扇初始状态
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 2   

  55          u8 gired_data[4];//存储4个字节接收码（地址码+地址反码+控制码+控制反码）
  56          //#define DC_MOTOR_RUN_TIME     5000    //定义直流电机运行时间为5000ms
  57          u8 mode=0;  //数码管界面切换
  58          u8 one_tag=0; //界面切换需要
  59          u8 wendu_fuhao;  //温度正负标志
  60          //u8 save_value=0;  //
  61          u8 wendu=20;  //温控模式温度设定值
  62          u16 adc_value=0;  //adc模式，读取原始数据
  63          float adc_vol;//ADC电压值
  64          int temp_value; //转换后的温度绝对值 
  65          //标志位
  66          bit kaiji_tag=0; //开机标志
  67          bit dianjiqidong_tag=0;  //电机启动标志
  68          bit wenkongmoshi=0;  //温控模式标志
  69          bit shoukongmoshi=1;  //手控模式标志
  70          bit adckongmoshi=0;  //adc控制模式标志
  71          bit guangming=0;  //adc的光敏模式标志
  72          bit reming=0;    //adc的热敏模式标志
  73          bit dianzu=1;    //adc的电阻模式标志
  74          bit suoanjian=0;  //锁主机按键标志
  75          //****************************************底层代码区******************************************************
             -*******
  76          /*******************************************************************************
  77          * 函 数 名       : delay_ms
  78          * 函数功能               : ms延时函数，ms=1时，大约延时1ms
  79          * 输    入       : ms：ms延时时间
  80          * 输    出       : 无
  81          *******************************************************************************/
  82          void delay_ms(u16 ms)
  83          {
  84   1              u16 i,j;
  85   1              for(i=ms;i>0;i--)
  86   1                      for(j=110;j>0;j--);
  87   1      }
  88          void delay_10us(u16 ten_us)
  89          {
  90   1              while(ten_us--);
  91   1      }
  92          
  93          /*******************************************************************************
  94          * 函 数 名       : Key_Read
  95          * 函数功能               : 矩阵按键扫描函数
  96          * 输    入       : 无
  97          * 输    出       : 键值
  98          *******************************************************************************/
  99          unsigned char Key_Read(void)
 100          {
 101   1              if(!KEY1)return 17;
 102   1              else if(!KEY2)return 18;
 103   1              //else if(!KEY3)return 19;  //被红外占用P32io口
 104   1              else if(!KEY4)return 20;
 105   1              if(kaiji_tag==1)
 106   1              {
 107   2      //    P10=0;P11=1;P12=1;P13=1;P14=1;P15=1;
 108   2      //    if(!P14)return 16;
 109   2      //    else if(!P15)return 12;
 110   2      //    else if(!P16)return 8;
 111   2      //    else if(!P17)return 4;
 112   2      //    P10=1;
 113   2              P11=0;P12=1;P13=1;P14=1;P15=1;
 114   2          if(!P14)return 15;
 115   2          else if(!P15)return 11;
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 3   

 116   2          else if(!P16)return 7;
 117   2          else if(!P17)return 3;
 118   2          P11=1;P12=0;
 119   2          if(!P14)return 14;
 120   2          else if(!P15)return 10;
 121   2          else if(!P16)return 6;
 122   2          else if(!P17)return 2;
 123   2          P12=1;P13=0;
 124   2          if(!P14)return 13;
 125   2          else if(!P15)return 9;
 126   2          else if(!P16)return 5;
 127   2          else if(!P17)return 1;
 128   2              }
 129   1          return 0;
 130   1      }
 131          
 132          /*******************************************************************************
 133          * 函 数 名         : ds18b20_reset
 134          * 函数功能                 : 复位DS18B20  
 135          * 输    入         : 无
 136          * 输    出         : 无
 137          *******************************************************************************/
 138          void ds18b20_reset(void)
 139          {
 140   1              DS18B20_PORT=0; //拉低DQ
 141   1              delay_10us(75); //拉低750us
 142   1              DS18B20_PORT=1; //DQ=1
 143   1              delay_10us(2);  //20US
 144   1      }
 145          
 146          /*******************************************************************************
 147          * 函 数 名         : ds18b20_check
 148          * 函数功能                 : 检测DS18B20是否存在
 149          * 输    入         : 无
 150          * 输    出         : 1:未检测到DS18B20的存在，0:存在
 151          *******************************************************************************/
 152          u8 ds18b20_check(void)
 153          {
 154   1              u8 time_temp=0;
 155   1      
 156   1              while(DS18B20_PORT&&time_temp<20)       //等待DQ为低电平
 157   1              {
 158   2                      time_temp++;
 159   2                      delay_10us(1);  
 160   2              }
 161   1              if(time_temp>=20)return 1;      //如果超时则强制返回1
 162   1              else time_temp=0;
 163   1              while((!DS18B20_PORT)&&time_temp<20)    //等待DQ为高电平
 164   1              {
 165   2                      time_temp++;
 166   2                      delay_10us(1);
 167   2              }
 168   1              if(time_temp>=20)return 1;      //如果超时则强制返回1
 169   1              return 0;
 170   1      }
 171          
 172          /*******************************************************************************
 173          * 函 数 名         : ds18b20_read_bit
 174          * 函数功能                 : 从DS18B20读取一个位
 175          * 输    入         : 无
 176          * 输    出         : 1/0
 177          *******************************************************************************/
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 4   

 178          u8 ds18b20_read_bit(void)
 179          {
 180   1              u8 dat=0;
 181   1              
 182   1              DS18B20_PORT=0;
 183   1              _nop_();_nop_();
 184   1              DS18B20_PORT=1; 
 185   1              _nop_();_nop_(); //该段时间不能过长，必须在15us内读取数据
 186   1              if(DS18B20_PORT)dat=1;  //如果总线上为1则数据dat为1，否则为0
 187   1              else dat=0;
 188   1              delay_10us(5);
 189   1              return dat;
 190   1      } 
 191          
 192          /*******************************************************************************
 193          * 函 数 名         : ds18b20_read_byte
 194          * 函数功能                 : 从DS18B20读取一个字节
 195          * 输    入         : 无
 196          * 输    出         : 一个字节数据
 197          *******************************************************************************/
 198          u8 ds18b20_read_byte(void)
 199          {
 200   1              u8 i=0;
 201   1              u8 dat=0;
 202   1              u8 temp=0;
 203   1      
 204   1              for(i=0;i<8;i++)//循环8次，每次读取一位，且先读低位再读高位
 205   1              {
 206   2                      temp=ds18b20_read_bit();
 207   2                      dat=(temp<<7)|(dat>>1);
 208   2              }
 209   1              return dat;     
 210   1      }
 211          
 212          /*******************************************************************************
 213          * 函 数 名         : ds18b20_write_byte
 214          * 函数功能                 : 写一个字节到DS18B20
 215          * 输    入         : dat：要写入的字节
 216          * 输    出         : 无
 217          *******************************************************************************/
 218          void ds18b20_write_byte(u8 dat)
 219          {
 220   1              u8 i=0;
 221   1              u8 temp=0;
 222   1      
 223   1              for(i=0;i<8;i++)//循环8次，每次写一位，且先写低位再写高位
 224   1              {
 225   2                      temp=dat&0x01;//选择低位准备写入
 226   2                      dat>>=1;//将次高位移到低位
 227   2                      if(temp)
 228   2                      {
 229   3                              DS18B20_PORT=0;
 230   3                              _nop_();_nop_();
 231   3                              DS18B20_PORT=1; 
 232   3                              delay_10us(6);
 233   3                      }
 234   2                      else
 235   2                      {
 236   3                              DS18B20_PORT=0;
 237   3                              delay_10us(6);
 238   3                              DS18B20_PORT=1;
 239   3                              _nop_();_nop_();        
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 5   

 240   3                      }       
 241   2              }       
 242   1      }
 243          
 244          /*******************************************************************************
 245          * 函 数 名         : ds18b20_start
 246          * 函数功能                 : 开始温度转换
 247          * 输    入         : 无
 248          * 输    出         : 无
 249          *******************************************************************************/
 250          void ds18b20_start(void)
 251          {
 252   1              ds18b20_reset();//复位
 253   1              ds18b20_check();//检查DS18B20
 254   1              ds18b20_write_byte(0xcc);//SKIP ROM
 255   1          ds18b20_write_byte(0x44);//转换命令 
 256   1      }
 257          
 258          /*******************************************************************************
 259          * 函 数 名         : ds18b20_init
 260          * 函数功能                 : 初始化DS18B20的IO口 DQ 同时检测DS的存在
 261          * 输    入         : 无
 262          * 输    出         : 1:不存在，0:存在
 263          *******************************************************************************/ 
 264          u8 ds18b20_init(void)
 265          {
 266   1              ds18b20_reset();
 267   1              return ds18b20_check(); 
 268   1      }
 269          
 270          /*******************************************************************************
 271          * 函 数 名         : ds18b20_read_temperture
 272          * 函数功能                 : 从ds18b20得到温度值
 273          * 输    入         : 无
 274          * 输    出         : 温度数据
 275          *******************************************************************************/
 276          float ds18b20_read_temperture(void)
 277          {
 278   1              float temp;
 279   1              u8 dath=0;
 280   1              u8 datl=0;
 281   1              u16 value=0;
 282   1      
 283   1              ds18b20_start();//开始转换
 284   1              ds18b20_reset();//复位
 285   1              ds18b20_check();
 286   1              ds18b20_write_byte(0xcc);//SKIP ROM
 287   1          ds18b20_write_byte(0xbe);//读存储器
 288   1      
 289   1              datl=ds18b20_read_byte();//低字节
 290   1              dath=ds18b20_read_byte();//高字节
 291   1              value=(dath<<8)+datl;//合并为16位数据
 292   1      
 293   1              if((value&0xf800)==0xf800)//判断符号位，负温度
 294   1              {
 295   2                      value=(~value)+1; //数据取反再加1
 296   2                      temp=value*(-0.0625);//乘以精度 
 297   2              }
 298   1              else //正温度
 299   1              {
 300   2                      temp=value*0.0625;      
 301   2              }
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 6   

 302   1              return temp;
 303   1      }
 304          
 305          /*******************************************************************************
 306          * 函 数 名       : ired_init
 307          * 函数功能               : 红外接受初始化函数
 308          * 输    入       : 无
 309          * 输    出       : 无
 310          *******************************************************************************/
 311          void ired_init(void)
 312          {
 313   1              IT0=1;  //下降沿触发
 314   1              EX0=1;  //打开中断0允许
 315   1              EA=1;   //打开总中断
 316   1              IRED=1; //初始化端口
 317   1      }
 318          /*******************************************************************************
 319          * 函 数 名       : ired
 320          * 函数功能               : 红外接受中断函数，外部中断0触发
 321          * 输    入       : 无
 322          * 输    出       : 无
 323          *******************************************************************************/
 324          void ired() interrupt 0 //外部中断0服务函数
 325          {
 326   1              u8 ired_high_time=0;
 327   1              u16 time_cnt=0;
 328   1              u8 i=0,j=0;
 329   1      
 330   1              if(IRED==0)
 331   1              {
 332   2                      time_cnt=1000;
 333   2                      while((!IRED)&&(time_cnt))//等待引导信号9ms低电平结束，若超过10ms强制退出
 334   2                      {
 335   3                              delay_10us(1);//延时约10us
 336   3                              time_cnt--;
 337   3                              if(time_cnt==0)return;          
 338   3                      }
 339   2                      if(IRED)//引导信号9ms低电平已过，进入4.5ms高电平
 340   2                      {
 341   3                              time_cnt=500;
 342   3                              while(IRED&&time_cnt)//等待引导信号4.5ms高电平结束，若超过5ms强制退出
 343   3                              {
 344   4                                      delay_10us(1);
 345   4                                      time_cnt--;
 346   4                                      if(time_cnt==0)return;  
 347   4                              }
 348   3                              for(i=0;i<4;i++)//循环4次，读取4个字节数据
 349   3                              {
 350   4                                      for(j=0;j<8;j++)//循环8次读取每位数据即一个字节
 351   4                                      {
 352   5                                              time_cnt=600;
 353   5                                              while((IRED==0)&&time_cnt)//等待数据1或0前面的0.56ms结束，若超过6ms强制退出
 354   5                                              {
 355   6                                                      delay_10us(1);
 356   6                                                      time_cnt--;
 357   6                                                      if(time_cnt==0)return;  
 358   6                                              }
 359   5                                              time_cnt=20;
 360   5                                              while(IRED)//等待数据1或0后面的高电平结束，若超过2ms强制退出
 361   5                                              {
 362   6                                                      delay_10us(10);//约0.1ms
 363   6                                                      ired_high_time++;
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 7   

 364   6                                                      if(ired_high_time>20)return;    
 365   6                                              }
 366   5                                              gired_data[i]>>=1;//先读取的为低位，然后是高位
 367   5                                              if(ired_high_time>=8)//如果高电平时间大于0.8ms，数据则为1，否则为0
 368   5                                                      gired_data[i]|=0x80;
 369   5                                              ired_high_time=0;//重新清零，等待下一次计算时间
 370   5                                      }
 371   4                              }
 372   3                      }
 373   2                      if(gired_data[2]!=~gired_data[3])//校验控制码与反码，错误则返回
 374   2                      {
 375   3                              for(i=0;i<4;i++)
 376   3                                      gired_data[i]=0;
 377   3                              return; 
 378   3                      }
 379   2              }               
 380   1      }
 381          
 382          /*******************************************************************************
 383          * 函 数 名       : iic_start
 384          * 函数功能               : 产生IIC起始信号
 385          * 输    入       : 无
 386          * 输    出       : 无
 387          *******************************************************************************/
 388          void iic_start(void)
 389          {
 390   1              IIC_SDA=1;//如果把该条语句放在SCL后面，第二次读写会出现问题
 391   1              delay_10us(1);
 392   1              IIC_SCL=1;
 393   1              delay_10us(1);
 394   1              IIC_SDA=0;      //当SCL为高电平时，SDA由高变为低
 395   1              delay_10us(1);
 396   1              IIC_SCL=0;//钳住I2C总线，准备发送或接收数据
 397   1              delay_10us(1);
 398   1      }
 399          
 400          /*******************************************************************************
 401          * 函 数 名         : iic_stop
 402          * 函数功能                 : 产生IIC停止信号   
 403          * 输    入         : 无
 404          * 输    出         : 无
 405          *******************************************************************************/
 406          void iic_stop(void)
 407          {       
 408   1              IIC_SDA=0;//如果把该条语句放在SCL后面，第二次读写会出现问题
 409   1              delay_10us(1);
 410   1              IIC_SCL=1;
 411   1              delay_10us(1);
 412   1              IIC_SDA=1;      //当SCL为高电平时，SDA由低变为高
 413   1              delay_10us(1);                  
 414   1      }
 415          
 416          /*******************************************************************************
 417          * 函 数 名         : iic_ack
 418          * 函数功能                 : 产生ACK应答  
 419          * 输    入         : 无
 420          * 输    出         : 无
 421          *******************************************************************************/
 422          void iic_ack(void)
 423          {
 424   1              IIC_SCL=0;
 425   1              IIC_SDA=0;      //SDA为低电平
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 8   

 426   1              delay_10us(1);
 427   1              IIC_SCL=1;
 428   1              delay_10us(1);
 429   1              IIC_SCL=0;
 430   1      }
 431          
 432          /*******************************************************************************
 433          * 函 数 名         : iic_nack
 434          * 函数功能                 : 产生NACK非应答  
 435          * 输    入         : 无
 436          * 输    出         : 无
 437          *******************************************************************************/
 438          void iic_nack(void)
 439          {
 440   1              IIC_SCL=0;
 441   1              IIC_SDA=1;      //SDA为高电平
 442   1              delay_10us(1);
 443   1              IIC_SCL=1;
 444   1              delay_10us(1);
 445   1              IIC_SCL=0;      
 446   1      }
 447          
 448          /*******************************************************************************
 449          * 函 数 名         : iic_wait_ack
 450          * 函数功能                 : 等待应答信号到来   
 451          * 输    入         : 无
 452          * 输    出         : 1，接收应答失败
 453                                           0，接收应答成功
 454          *******************************************************************************/
 455          u8 iic_wait_ack(void)
 456          {
 457   1              u8 time_temp=0;
 458   1              
 459   1              IIC_SCL=1;
 460   1              delay_10us(1);
 461   1              while(IIC_SDA)  //等待SDA为低电平
 462   1              {
 463   2                      time_temp++;
 464   2                      if(time_temp>100)//超时则强制结束IIC通信
 465   2                      {       
 466   3                              iic_stop();
 467   3                              return 1;       
 468   3                      }                       
 469   2              }
 470   1              IIC_SCL=0;
 471   1              return 0;       
 472   1      }
 473          
 474          /*******************************************************************************
 475          * 函 数 名         : iic_write_byte
 476          * 函数功能                 : IIC发送一个字节 
 477          * 输    入         : dat：发送一个字节
 478          * 输    出         : 无
 479          *******************************************************************************/
 480          void iic_write_byte(u8 dat)
 481          {                        
 482   1          u8 i=0; 
 483   1                          
 484   1          IIC_SCL=0;
 485   1          for(i=0;i<8;i++)    //循环8次将一个字节传出，先传高再传低位
 486   1          {              
 487   2              if((dat&0x80)>0) 
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 9   

 488   2                              IIC_SDA=1;
 489   2                      else
 490   2                              IIC_SDA=0;
 491   2              dat<<=1;          
 492   2                      delay_10us(1);  
 493   2                      IIC_SCL=1;
 494   2                      delay_10us(1); 
 495   2                      IIC_SCL=0;      
 496   2                      delay_10us(1);
 497   2          }    
 498   1      }
 499          
 500          /*******************************************************************************
 501          * 函 数 名         : iic_read_byte
 502          * 函数功能                 : IIC读一个字节 
 503          * 输    入         : ack=1时，发送ACK，ack=0，发送nACK 
 504          * 输    出         : 应答或非应答
 505          *******************************************************************************/
 506          u8 iic_read_byte(u8 ack)
 507          {
 508   1              u8 i=0,receive=0;
 509   1              
 510   1          for(i=0;i<8;i++ )   //循环8次将一个字节读出，先读高再传低位
 511   1              {
 512   2              IIC_SCL=0; 
 513   2              delay_10us(1);
 514   2                      IIC_SCL=1;
 515   2              receive<<=1;
 516   2              if(IIC_SDA)receive++;   
 517   2                      delay_10us(1); 
 518   2          }                                    
 519   1          if (!ack)
 520   1              iic_nack();
 521   1          else
 522   1              iic_ack();  
 523   1                        
 524   1          return receive;
 525   1      }
 526          
 527          /*******************************************************************************
 528          * 函 数 名         : at24c02_write_one_byte
 529          * 函数功能                 : 在AT24CXX指定地址写入一个数据
 530          * 输    入         : addr:写入数据的目的地址 
 531                                                   dat:要写入的数据
 532          * 输    出         : 无
 533          *******************************************************************************/
 534          void at24c02_write_one_byte(u8 addr,u8 dat)
 535          {                                                                                                                                                                                
 536   1          iic_start();  
 537   1              iic_write_byte(0XA0);   //发送写命令              
 538   1              iic_wait_ack();    
 539   1          iic_write_byte(addr);       //发送写地址   
 540   1              iic_wait_ack();                                                                                                            
 541   1              iic_write_byte(dat);    //发送字节                                                         
 542   1              iic_wait_ack();                            
 543   1          iic_stop();                         //产生一个停止条件
 544   1              delay_ms(10);    
 545   1      }
 546          
 547          /*******************************************************************************
 548          * 函 数 名         : at24c02_read_one_byte
 549          * 函数功能                 : 在AT24CXX指定地址读出一个数据
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 10  

 550          * 输    入         : addr:开始读数的地址 
 551          * 输    出         : 读到的数据
 552          *******************************************************************************/
 553          u8 at24c02_read_one_byte(u8 addr)
 554          {                                 
 555   1              u8 temp=0;                                                                                                                                                       
 556   1          iic_start();  
 557   1              iic_write_byte(0XA0);   //发送写命令       
 558   1              iic_wait_ack(); 
 559   1          iic_write_byte(addr);       //发送写地址  
 560   1              iic_wait_ack();     
 561   1              iic_start();               
 562   1              iic_write_byte(0XA1);   //进入接收模式                             
 563   1              iic_wait_ack();  
 564   1          temp=iic_read_byte(0);      //读取字节                 
 565   1          iic_stop();                         //产生一个停止条件    
 566   1              return temp;                    //返回读取的数据
 567   1      }
 568          
 569          /*******************************************************************************
 570          * 函 数 名       : xpt2046_wirte_data
 571          * 函数功能               : XPT2046写数据
 572          * 输    入       : dat：写入的数据
 573          * 输    出       : 无
 574          *******************************************************************************/
 575          void xpt2046_wirte_data(u8 dat)
 576          {
 577   1              u8 i;
 578   1      
 579   1              CLK = 0;
 580   1              _nop_();
 581   1              for(i=0;i<8;i++)//循环8次，每次传输一位，共一个字节
 582   1              {
 583   2                      DIN = dat >> 7;//先传高位再传低位
 584   2                      dat <<= 1;//将低位移到高位
 585   2                      CLK = 0;//CLK由低到高产生一个上升沿，从而写入数据
 586   2                      _nop_();        
 587   2                      CLK = 1;
 588   2                      _nop_();
 589   2              }
 590   1      }
 591          
 592          /*******************************************************************************
 593          * 函 数 名       : xpt2046_read_data
 594          * 函数功能               : XPT2046读数据
 595          * 输    入       : 无
 596          * 输    出       : XPT2046返回12位数据
 597          *******************************************************************************/
 598          u16     xpt2046_read_data(void)
 599          {
 600   1              u8 i;
 601   1              u16 dat=0;
 602   1      
 603   1              CLK = 0;
 604   1              _nop_();
 605   1              for(i=0;i<12;i++)//循环12次，每次读取一位，大于一个字节数，所以返回值类型是u16
 606   1              {
 607   2                      dat <<= 1;
 608   2                      CLK = 1;
 609   2                      _nop_();
 610   2                      CLK = 0; //CLK由高到低产生一个下降沿，从而读取数据
 611   2                      _nop_();
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 11  

 612   2                      dat |= DOUT;//先读取高位，再读取低位。  
 613   2              }
 614   1              return dat;     
 615   1      }
 616          
 617          /*******************************************************************************
 618          * 函 数 名       : xpt2046_read_adc_value
 619          * 函数功能               : XPT2046读AD数据
 620          * 输    入       : cmd：指令
 621          * 输    出       : XPT2046返回AD值
 622          *******************************************************************************/
 623          u16 xpt2046_read_adc_value(u8 cmd)
 624          {
 625   1              u8 i;
 626   1              u16 adc_value=0;
 627   1      
 628   1              CLK = 0;//先拉低时钟
 629   1              CS  = 0;//使能XPT2046
 630   1              xpt2046_wirte_data(cmd);//发送命令字
 631   1              for(i=6; i>0; i--);//延时等待转换结果
 632   1              CLK = 1;
 633   1              _nop_();
 634   1              CLK = 0;//发送一个时钟，清除BUSY
 635   1              _nop_();
 636   1              adc_value=xpt2046_read_data();
 637   1              CS = 1;//关闭XPT2046
 638   1              return adc_value;
 639   1      }
 640          
 641          /*******************************************************************************
 642          * 函 数 名       : Timer0Init
 643          * 函数功能               : 定时器0初始化
 644          * 输    入       : 无
 645          * 输    出       : 无
 646          *******************************************************************************/
 647          void Timer0Init(void)           
 648          {
 649   1              TMOD |= 0x01;           //设置定时器模式
 650   1              TL0 = 0x9A;             //设置定时初始值
 651   1              TH0 = 0xA9;             //设置定时初始值
 652   1              TF0 = 0;                //清除TF0标志
 653   1              ET0=1;                  //打开中断
 654   1              TR0 = 1;                //定时器0开始计时
 655   1              EA=1;                   //打开总中断
 656   1      }
 657          
 658          /*******************************************************************************
 659          * 函 数 名       : Timer1Init
 660          * 函数功能               : 定时器1初始化
 661          * 输    入       : 无
 662          * 输    出       : 无
 663          *******************************************************************************/
 664          void Timer1Init(void)           
 665          {
 666   1      
 667   1              TMOD |= 0x10;           //设置定时器模式
 668   1              TL1 = 0x91;             //设置定时初始值
 669   1              TH1 = 0xFf;             //设置定时初始值
 670   1              TF1 = 0;                //清除TF1标志
 671   1              TR1 = 1;                //定时器1开始计时
 672   1              ET1=1;                  //打开中断
 673   1              EA=1;                   //打开总中断
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 12  

 674   1      }
 675          
 676          //****************************************主函数区********************************************************
             -*****
 677          void main()
 678          {
 679   1              DC_Motor=0;    //上电，使电机处于停转状态
 680   1              wendu=at24c02_read_one_byte(EEPROM_ADDRESS);  //从eeprom中读取数据
 681   1              Timer0Init();   //定时器0初始化
 682   1              Timer1Init();   //定时器1初始化
 683   1              ired_init();//红外初始化
 684   1              ds18b20_init();//初始化DS18B20
 685   1              while(1)                
 686   1              {
 687   2                      if(wenkongmoshi==1&&kaiji_tag==1){LED1=0;LED2=1;LED3=1;}
 688   2                      if(adckongmoshi==1&&kaiji_tag==1){LED1=1;LED2=0;LED3=1;}
 689   2                      if(shoukongmoshi==1&&kaiji_tag==1){LED1=1;LED2=1;LED3=0;}
 690   2                      switch(mode)
 691   2              {
 692   3                  case 0:
 693   3                  {
 694   4                      if(one_tag!=0){one_tag=0;seg[0]=28;
 695   5                                      seg[1]=28;
 696   5                                      seg[2]=28;
 697   5                                      seg[3]=28;
 698   5                                      seg[4]=28;
 699   5                                      seg[5]=28;
 700   5                                      seg[6]=28;
 701   5                                      seg[7]=28;}
 702   4      
 703   4                  }
 704   3                  break;
 705   3                  case 1:
 706   3                  {
 707   4                      if(one_tag!=1){one_tag=1;}
 708   4                                      seg[0]=27;
 709   4                                      seg[1]=duty/100%10;
 710   4                                      seg[2]=duty/10%10;
 711   4                                      seg[3]=duty/1%10;
 712   4                                      seg[4]=wendu_fuhao;
 713   4                                      seg[5]=temp_value/100%10;
 714   4                                      seg[6]=temp_value/10%10+16;
 715   4                                      seg[7]=temp_value/1%10;
 716   4                                      //seg[5]=gsmg_code[gired_data[2]/16];
 717   4                                      //seg[6]=gsmg_code[gired_data[2]%16];
 718   4      //                seg[0]=ds18b20/100000;
 719   4      //                seg[1]=ds18b20/10000%10+16;
 720   4      //                seg[2]=ds18b20/1000%10;
 721   4      //                seg[3]=ds18b20/100%10;
 722   4      //                seg[4]=ds18b20/10%10;
 723   4      //                seg[5]=ds18b20%10;
 724   4                  }
 725   3                  break;
 726   3                  case 2:
 727   3                  {
 728   4                      if(one_tag!=2){one_tag=2;}
 729   4                                      seg[0]=26;
 730   4                                      seg[1]=28;
 731   4                                      seg[2]=28;
 732   4                                      seg[3]=28;
 733   4                                      seg[4]=28;
 734   4                                      seg[5]=28;
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 13  

 735   4                                      seg[6]=wendu/10;
 736   4                                      seg[7]=wendu%10;
 737   4                  }
 738   3                  break;
 739   3                              case 3:
 740   3                  {
 741   4                      if(one_tag!=2){one_tag=2;seg[6]=28;}
 742   4                                      if(wenkongmoshi==1)seg[0]=1;else seg[0]=28;             //第一位数码管显示1表示温控模式
 743   4                                      if(adckongmoshi==1)seg[1]=1;else seg[1]=28;             //第二位数码管显示1表示adc模式
 744   4                                      if(shoukongmoshi==1)seg[2]=1;else seg[2]=28;    //第三位数码管显示1表示手控模式
 745   4                                      if(adckongmoshi==1&&dianzu==1)seg[3]=1;else seg[3]=28;  //第四位数码管显示1表示adc的电阻模式
 746   4                                      if(adckongmoshi==1&&guangming==1)seg[4]=1;else seg[4]=28;  //第五位数码管显示1表示adc的光敏模式
 747   4                                      if(adckongmoshi==1&&reming==1)seg[5]=1;else seg[5]=28;          //第六位数码管显示1表示adc的热敏模式
 748   4                                      if(suoanjian==1)seg[7]=1;else seg[7]=28;   //第八位数码管显示1表示主机按键不能使用。
 749   4      
 750   4                  }
 751   3                  break;
 752   3              }
 753   2                      
 754   2                      if((int)(temp_value/10)>(wendu+1)&&wenkongmoshi==1)
 755   2                      {
 756   3                              duty=0;
 757   3                      }
 758   2                      else if((int)(temp_value/10)<(wendu-1)&&wenkongmoshi==1)
 759   2                      {
 760   3                              duty=60;
 761   3                      }
 762   2                      else if((int)(temp_value/10)<(wendu+1)&&(int)(temp_value/10)>(wendu-1)&&wenkongmoshi==1)
 763   2                      {
 764   3                              duty=30;
 765   3                      }
 766   2                      if(adckongmoshi==1&&dianzu==1)
 767   2                      {
 768   3                              if(adc_value<50)duty=0;
 769   3                              else if(adc_value>4050)duty=100;
 770   3                              else duty=adc_value/100;
 771   3                      }
 772   2                      if(adckongmoshi==1&&guangming==1)
 773   2                      {
 774   3                              if(adc_value<100)duty=100; //黑，晚上不转
 775   3                              else if(adc_value>1000)duty=0;
 776   3                              else duty=100-(adc_value/10);
 777   3                      }
 778   2                      if(adckongmoshi==1&&reming==1)
 779   2                      {
 780   3                              if((adc_value-1500)<100)duty=100; //温度低，不转
 781   3                              else if((adc_value-1500)>500)duty=0;
 782   3                              else duty=60-((adc_value-1600)/7);
 783   3                      }
 784   2                      if(gired_data[2]==0x45)
 785   2                      {
 786   3                                      kaiji_tag=!kaiji_tag;
 787   3                                      if(kaiji_tag==0)
 788   3                                      {
 789   4                                              dianjiqidong_tag=0;
 790   4                                              mode=0;
 791   4                                              DC_Motor=0;
 792   4                                              P2=0xff;
 793   4                                              //duty=100;
 794   4                                      }
 795   3                                      else 
 796   3                                      {
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 14  

 797   4                                              mode=1;
 798   4                                              //DC_Motor=0;
 799   4                                              //dianjiqidong_tag=0;
 800   4                                      }
 801   3                      }
 802   2                      if(gired_data[2]==0x44&&kaiji_tag==1){dianjiqidong_tag=!dianjiqidong_tag;DC_Motor=0;}
 803   2                      if(gired_data[2]==0x07&&kaiji_tag==1&&mode==2)
 804   2                              {
 805   3                                      at24c02_write_one_byte(EEPROM_ADDRESS,wendu);
 806   3                              }
 807   2                              if(gired_data[2]==0x46&&kaiji_tag==1)
 808   2                              {
 809   3                                      if(wenkongmoshi==1){wenkongmoshi=0;adckongmoshi=1;shoukongmoshi=0;}
 810   3                                      else if(adckongmoshi==1){wenkongmoshi=0;adckongmoshi=0;shoukongmoshi=1;}
 811   3                                      else if(shoukongmoshi==1){wenkongmoshi=1;adckongmoshi=0;shoukongmoshi=0;}
 812   3                              }
 813   2                              if(gired_data[2]==0x47&&kaiji_tag==1){suoanjian=!suoanjian;}
 814   2                              if(gired_data[2]==0x40&&kaiji_tag==1){wendu--;if(wendu<=14)wendu=15;}
 815   2                              if(gired_data[2]==0x43&&kaiji_tag==1){wendu++;if(wendu>=36)wendu=35;}
 816   2                      if(gired_data[2]==0x15&&kaiji_tag==1&&adckongmoshi==1)
 817   2                      {
 818   3                              if(guangming==1){guangming=0;reming=1;dianzu=0;}
 819   3                              else if(reming==1){guangming=0;reming=0;dianzu=1;}
 820   3                              else if(dianzu==1){guangming=1;reming=0;dianzu=0;}
 821   3                      }
 822   2                      if(gired_data[2]==0x09&&kaiji_tag==1)
 823   2                      {
 824   3                              if(guangming==1){guangming=0;reming=0;dianzu=1;}
 825   3                              else if(reming==1){guangming=1;reming=0;dianzu=0;}
 826   3                              else if(dianzu==1){guangming=0;reming=1;dianzu=0;}
 827   3                      }
 828   2                      if(gired_data[2]==0x19&&kaiji_tag==1)
 829   2                      {       
 830   3                              if(mode==1)mode=3;
 831   3                              else if(mode==3)mode=1;
 832   3                              else if(mode==2)mode=1;
 833   3                      }
 834   2                      if(gired_data[2]==0x0d&&kaiji_tag==1){mode=2;}
 835   2                      if(kaiji_tag==1)
 836   2                      {
 837   3                      if(gired_data[2]==0x16)duty=0;
 838   3                      if(gired_data[2]==0x0c)duty=6;
 839   3                      if(gired_data[2]==0x18)duty=12;
 840   3                      if(gired_data[2]==0x5e)duty=18;
 841   3                      if(gired_data[2]==0x08)duty=24;
 842   3                      if(gired_data[2]==0x1c)duty=30;
 843   3                      if(gired_data[2]==0x5a)duty=36;
 844   3                      if(gired_data[2]==0x42)duty=42;
 845   3                      if(gired_data[2]==0x52)duty=48;
 846   3                      if(gired_data[2]==0x4a)duty=54;
 847   3                      }
 848   2                      gired_data[2]=0;
 849   2      //*******************main按键控制区**********
 850   2                      if(key_down)
 851   2              { 
 852   3                              if(suoanjian==0)
 853   3                              {
 854   4                              if(key_down==1&&kaiji_tag==1){wendu--;if(wendu<=14)wendu=15;}
 855   4                              if(key_down==2&&kaiji_tag==1)
 856   4                              {
 857   5                                      mode=2;
 858   5                              }
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 15  

 859   4                              if(key_down==3&&kaiji_tag==1){wendu++;if(wendu>=36)wendu=35;}
 860   4      //                      if(key_down==4){duty=0;}
 861   4                              
 862   4                              if(key_down==5&&adckongmoshi==1){guangming=1;reming=0;dianzu=0;}
 863   4                              if(key_down==6&&kaiji_tag==1)
 864   4                              {
 865   5                                      if(mode==1)mode=3;
 866   5                                      else if(mode==3)mode=1;
 867   5                                      else if(mode==2)mode=1;
 868   5                              }
 869   4                              if(key_down==7&&adckongmoshi==1){guangming=0;reming=1;dianzu=0;}
 870   4      //                      if(key_down==8){duty=0;}
 871   4                              
 872   4                              if(key_down==9)
 873   4                              {
 874   5                                      wenkongmoshi=1;
 875   5                                      adckongmoshi=0;
 876   5                                      shoukongmoshi=0;
 877   5                              }//温控模式
 878   4                              if(key_down==10)
 879   4                              {
 880   5                                      wenkongmoshi=0;
 881   5                                      adckongmoshi=1;
 882   5                                      shoukongmoshi=0;
 883   5                                      guangming=0;reming=0;dianzu=1;
 884   5                              }//adc模式
 885   4                              if(key_down==11)
 886   4                              {
 887   5                                      wenkongmoshi=0;
 888   5                                      adckongmoshi=0;
 889   5                                      shoukongmoshi=1;
 890   5      
 891   5                              }//手控模式
 892   4      //                      if(key_down==12){duty=0;}
 893   4                              
 894   4                              if(key_down==13&&shoukongmoshi==1){duty=0;}
 895   4                              if(key_down==14&&shoukongmoshi==1){duty=30;}
 896   4                              if(key_down==15&&shoukongmoshi==1){duty=60;}
 897   4      //                      if(key_down==16){duty=100;}
 898   4                              }
 899   3                              if(key_down==17)
 900   3                              {
 901   4                                      kaiji_tag=!kaiji_tag;
 902   4                                      if(kaiji_tag==0)
 903   4                                      {
 904   5                                              dianjiqidong_tag=0;
 905   5                                              mode=0;
 906   5                                              DC_Motor=0;
 907   5                                              P2=0xff;
 908   5                                              //duty=100;
 909   5                                      }
 910   4                                      else 
 911   4                                      {
 912   5                                              mode=1;
 913   5                                              //DC_Motor=0;
 914   5                                              //dianjiqidong_tag=0;
 915   5                                      }
 916   4                              }
 917   3                              if(key_down==18&&kaiji_tag==1&&mode==2)
 918   3                              {
 919   4                                      at24c02_write_one_byte(EEPROM_ADDRESS,wendu);
 920   4                              }
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 16  

 921   3                              //if(key_down==19){duty=40;}  //被红外占用P32io口
 922   3                              if(key_down==20&&kaiji_tag==1){dianjiqidong_tag=!dianjiqidong_tag;DC_Motor=0;}
 923   3      
 924   3                key_down =0;
 925   3              }
 926   2      //**********************按键控制区结束********************
 927   2      
 928   2              }               
 929   1      }
 930          
 931          //****************************************温度按键扫描区**************************************************
             -***********
 932          
 933          void tim0(void) interrupt 1
 934          {
 935   1              TL0 = 0x9A;             //设置定时初始值
 936   1              TH0 = 0xA9;             //设置定时初始值
 937   1              sys++;
 938   1              if(++key_sanf_delay == 10)key_sanf_delay=0;//10ms one keyboard scan
 939   1              if(adckongmoshi==1&&sys%5==0)
 940   1              {
 941   2                      if(dianzu==1)adc_value=xpt2046_read_adc_value(0x94);//测量电位器
 942   2                      if(reming==1)adc_value=xpt2046_read_adc_value(0xD4);//测量热敏电阻
 943   2                      if(guangming==1)adc_value=xpt2046_read_adc_value(0xA4);//测量光敏电阻
 944   2                      //sys=0;
 945   2              }
 946   1              if(sys%30==0)//间隔一段时间读取温度值，间隔时间要大于温度传感器转换温度时间
 947   1              {
 948   2                      temp_value=ds18b20_read_temperture()*10;//保留温度值小数后一位
 949   2                      if(temp_value<0)//负温度
 950   2                      {
 951   3                              temp_value=-temp_value;
 952   3                              wendu_fuhao=29;//显示负号       
 953   3                      }
 954   2                      else 
 955   2                      {
 956   3                              wendu_fuhao=28;//不显示
 957   3                      }
 958   2                      
 959   2              }
 960   1              
 961   1          if(key_sanf_delay==0)
 962   1          {
 963   2              key_sanf_delay=1;
 964   2              key_val=Key_Read();
 965   2              key_down = key_val & (key_old ^ key_val);
 966   2              key_up = ~key_val & (key_old ^ key_val);
 967   2              key_old = key_val;
 968   2          }
 969   1      }
 970          //****************************************pwm波，seg扫描区************************************************
             -*************
 971          
 972          void time1() interrupt 3 
 973          {
 974   1              static u16 i;
 975   1              static u16 j;
 976   1              TL1 = 0x91;             //设置定时初始值
 977   1              TH1 = 0xFf;             //设置定时初始值
 978   1              i++;
 979   1              if(i>=scale){i=0;}
 980   1              if(kaiji_tag==1)
C51 COMPILER V9.60.0.0   MAIN                                                              11/29/2023 00:03:10 PAGE 17  

 981   1              {
 982   2                      j++;
 983   2                      if(j>=4){j=0;seg_tag++;}
 984   2                      //SMG_A_DP_PORT=0XFF;
 985   2                      switch(seg_tag%8)
 986   2                      {
 987   3                              case 0: LSC=1;LSB=1;LSA=1;break;
 988   3                              case 1: LSC=1;LSB=1;LSA=0;break;
 989   3                              case 2: LSC=1;LSB=0;LSA=1;break;
 990   3                              case 3: LSC=1;LSB=0;LSA=0;break;
 991   3                              case 4: LSC=0;LSB=1;LSA=1;break;
 992   3                              case 5: LSC=0;LSB=1;LSA=0;break;
 993   3                              case 6: LSC=0;LSB=0;LSA=1;break;
 994   3                              case 7: LSC=0;LSB=0;LSA=0;break;
 995   3                      }
 996   2              }
 997   1                      SMG_A_DP_PORT=gsmg_code[seg[seg_tag%8]];
 998   1              if(dianjiqidong_tag==1)
 999   1              {
1000   2                      if(i>duty)
1001   2                      {
1002   3                              DC_Motor=1;
1003   3                      }
1004   2                      else
1005   2                      {
1006   3                              DC_Motor=0;
1007   3                              
1008   3                      }
1009   2              }
1010   1      }
1011          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3303    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     82       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
